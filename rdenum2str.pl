#!/usr/bin/perl
#
#
# librd - Rapid Development C library
#
# Copyright (c) 2012-2013, Magnus Edenhill
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#/
#



#
# Reads header file content from stdin and produces enum2str functions
# for each found typedeffed enum.
#
# Usage: cat *.h | ./enum2str.pl > autoenum.h
#
# Followed by:
#   #include "autoenum.h"
#


my $anonid = 1;
my $curr_enum = undef;

foreach (<STDIN>) {
    chomp;

    if (/^\s*(typedef)\s*enum\s*\{?/) {
	$curr_enum = ++$anonid;
    } elsif ($curr_enum && /^\s*\}\s*(\S+)?\s*\;/) {
	my $name;
	if ($1) {
	    $enum{$curr_enum}->{origtype} = $1;
	    $name = $1;
	    $name =~ s/_t$//;
	    $enum{$curr_enum}->{name} = $name;
	    if (scalar @{ $enum{$curr_enum}->{items} } > 0) {
		push @good_enums, $curr_enum;
	    }
	}
	$curr_enum = undef;

    } elsif ($curr_enum && /^\s*(\S+)\s*,/) {
	push @{ $enum{$curr_enum}->{items} }, $1;
    }
}

my $date = scalar localtime;
print <<EOF;
/* DO NOT EDIT. AUTOMATICALLY GENERATED BY $0 ON $date */
#pragma once

EOF


foreach my $id (@good_enums) {
    my $n = $enum{$id}->{name};
    my $origtype = $enum{$id}->{origtype};
    next if (!$origtype);
    print <<EOF;
/**
 * Return $origtype enum name as string.
 * Thread-safe
 */
static const char *${n}2str ($origtype in) __attribute__((unused));
static const char *${n}2str ($origtype in) {
    static const char *desc[] = {
EOF
    foreach my $e (@{ $enum{$id}->{items} }) {
	print "        [$e] = \"$e\",\n";
    }

    print <<EOF;
    };

    return desc[in];
}


EOF

}

